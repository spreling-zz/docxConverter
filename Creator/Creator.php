<?php
/**
 * Creator.php
 *
 * The file contains the Creator class
 *
 * @package Creator
 *
 */

/**
 * Creator - parent to the code creators
 *
 * This class was the Parent class of all code creators. 
 * It was and still thinks it's a god who created everything in the universe, 
 * and because of that it was a bit of a Jerk. But i managed to mould it in a
 * super Creator. making all the demi god children obsoleet. This class can nou
 * give the right code depending on which markup sheet it is given.
 *
 * @author Spreling - Harm Jacob Drijfhout Email: Spreling@gmail.com
 * @version 2.0
 * @since 2.0
 * @copyright Spreling inc. 2013
 * @license Yet to detriment in the mean time it is not for common use and in
 * development.
 *
 * @abstract Parent class of the code creators
 *
 * @package Creator
 *
 * @see HtmlCreator
 * @see DokuWikiCreator
 */
class Creator {

	/**
	 * creationOuput
	 *
	 * this is the output code which is generated by the creator class and
	 * contain useable code
	 *
	 * @var String
	 */
	protected $creationOuput;

	/**
	 * buildingMaterials
	 *
	 * This is a array with mutiple arrays which contains neatly parserd data which
	 * can be used as buildingmaterials to create proper code
	 *
	 * @var Array
	 */
	protected $buildingMaterials;

	/** 
	 * markup
	 * 
	 * This is the array with the markup in it. This markup is used to created the usefull code
	 * 
	 * @var Array
	 */
	protected $markup;
	/**
	 * __construct - function to construct the class
	 *
	 * Constructor function for this class. Accepts a array of buildingMaterials and a array 
	 * with markup languages. both wil be used to created the useabel code.
	 *
	 * @name __construct
	 * @access public
	 * @since 3.5
	 *
	 * @param $buildingMaterials (Array) - The array of building Materials
	 */
	public function __construct($buildingMaterials, $markup) {
		$this->buildingMaterials = $buildingMaterials;
		$this->markup = $markup;
		//create Code depending on the child class which polymophs the function
		$this->creationOuput = $this->CreateCode();
	}
	/**
	 * CreateCode - function with whitch the code is created
	 *
	 * The methode is use to create code making use of the markup array en
	 * buildingmaterials
	 * 
	 * @name CreateCode
	 * @access protected
	 * @since 2.0
	 *
	 * @return $creationOuput (String) - string with code
	 */
	protected function CreateCode() {
		//Output variable
		$outputHTML = "";
		//gathers the neccesary array out of the build materials
		$documentObjects = $this->buildingMaterials['documentXML'];

		foreach ($documentObjects as $paragraaf) {
			//check what class it is
			switch ($paragraaf->getClassName()) {
				//create a heading
				case "headingParagraaf":
					$HeadingBeginPiece = str_replace("%headinglvl%", $paragraaf->getHeadingLevel(), $this->markup['HeadingBegin']);
					$HeadingEndPiece = str_replace("%headinglvl%", $paragraaf->getHeadingLevel(), $this->markup['HeadingEnd']);

					$HeadingBegin = "";
					$HeadingEnd = "";
					if (strtolower($this->markup['HeadingLvl']) != "false") {
						if ($this->markup['HeadingLvl'] == "+") {
							for ($i = 0; $i < $paragraaf->getHeadingLevel(); $i++) {
								$HeadingBegin .= $HeadingBeginPiece;
								$HeadingEnd .= $HeadingEndPiece;
							}
						} else {
							$amount = 6 - $paragraaf->getHeadingLevel();
							if ($amount < 1) {
								$amount = 1;
							}
							for ($i = 0; $i < $amount; $i++) {
								$HeadingBegin .= $HeadingBeginPiece;
								$HeadingEnd .= $HeadingEndPiece;
							}

						}

					} else {
						$HeadingBegin .= $HeadingBeginPiece;
						$HeadingEnd .= $HeadingEndPiece;
					}
					$outputHTML .= $HeadingBegin.$this->CreateTextpieces($paragraaf->getTextpieces(), $this->markup['HeadingNoFont']).$HeadingEnd."\r";

					//)
					break;
				//create a whitespace
				case "paragraaf":
					break;
				//create a Normal Paragraaf
				case "normaalParagraaf":
					$tempTextpieces = $paragraaf->getTextpieces();
					$tempTextpiece = end($tempTextpieces);

					if (count($paragraaf->getTextpieces()) != 0) {
						if (count($tempTextpieces) <= 1 && $tempTextpiece->getText() == "") {
							$outputHTML .= $this->markup['whitespace'];
						} else {
							$outputHTML .= $this->markup['ParagraafBegin'].$this->CreateTextpieces($paragraaf->getTextpieces(), $this->markup['ParagraafNoFont']).$this->markup['ParagraafEnd']."\r";
						}
					} else {
						$outputHTML .= $this->markup['whitespace']."\r";;
					}

					break;
				//create a Bullet List
				case "listParagraaf":

					//gathers a additional neccesary array out of the build materials
					$temp = $paragraaf->getNodes();
					$lastNode = end($temp);
					foreach ($this->buildingMaterials['subdocument']['numberingXML'] as $numeberInformationList) {
						if ($numeberInformationList->getId() == $lastNode->getListType()) {
							$temp = $numeberInformationList->getnumTypes();
							$numeType = end($temp);
							$listOrder = $numeType->getName();
						}
					}//determins if it is a order or unorderd list
					if ($listOrder == "bullet") {
						$listType['begin'] = $this->markup['UnorderdListBegin'];
						$listType['nodeBegin'] = $this->markup['UnorderdNodeBegin'];
						$listType['end'] = $this->markup['UnorderdListEnd'];
						$listType['nodeEnd'] = $this->markup['UnorderdNodeEnd'];
						$listType['Listindent'] = $this->markup['UnorderdListIndentChar'];
					} else {
						$listType['begin'] = $this->markup['OrderdListBegin'];
						$listType['nodeBegin'] = $this->markup['OrderdNodeBegin'];
						$listType['end'] = $this->markup['OrderdListEnd'];
						$listType['nodeEnd'] = $this->markup['OrderdNodeEnd'];
						$listType['Listindent'] = $this->markup['OrderdListIndentChar'];
					}

					$arrayobject = new ArrayObject($paragraaf->getNodes());
					$it = $arrayobject->getIterator();
					$it->rewind();

					$outputHTML .= $this->CreateBulletList($it, new listNodes( array(""), 0, 0), $listType, 0);

					//die();
					break;
				//create a error (this should not be possible)
				default:
					$outputHTML .= "--Unknown Header--";
			}
		}
		return $outputHTML;
	}
	/**
	 * CreateBulletList - Methode to create a bulletlist
	 *
	 * This methode makes useable bullet or orderd list. with all the font's given to the text
	 * This methode is recurif to create lvl depth
	 *
	 * @name CreateBulletList
	 * @access private
	 * @since 3.5
	 * 
	 * @param $it (iterator) -  the iterator which is used in te methode.
	 * @param $previousIt (iterator->current()-1) the previous item in the iterator
	 * @param $listtype (array) - orderd of unorderd list marukup
	 * @param $indentlvl (int) - depth of the recursie 
	 * @return $output (String) - a string which contains a bullet list writting in dokuwiki Code.
	 *
	 */
	private function CreateBulletList($it, $previousIt, $listType, $indentlvl) {
		$output = $listType['begin'];
		
		$indentString="";
		for ($i=0; $i < $indentlvl; $i++){
			$indentString .= $listType['Listindent'];
		}

		for ($it->current(); $it->valid(); $it->next()) {

			if ($it->current()->getIndent() == $previousIt->getIndent()) {
				$output .= $indentString.$listType['nodeBegin'].$this->CreateTextpieces($it->current()->getTextpieces(), $this->markup['ListNoFont']).$listType['nodeEnd'];
				$previousIt = $it->current();
			} elseif ($it->current()->getIndent() > $previousIt->getIndent()) {
				$indentlvl++;
				$previousIt = $it->current();
				$output .= $this->CreateBulletList($it, $previousIt, $listType, $indentlvl);
			} elseif ($it->current()->getIndent() < $previousIt->getIndent()) {
				$indentlvl--;
				$indentString="";
				for ($i=0; $i < $indentlvl; $i++){
					$indentString .= $listType['Listindent'];
				}
				$output .= $listType['end'];

				$output .= $indentString.$listType['nodeBegin'].$this->CreateTextpieces($it->current()->getTextpieces(), $this->markup['ListNoFont']).$listType['nodeEnd'];
				return $output;
			}

		}
		$indentlvl--;
		$output .= $listType['end'];
		return $output;
	}
	/**
	 * CreateTextpieces - Methode to create a textpiece with font 
	 *
	 * This methode makes a useable textpieces for a paragraaf. with all the font's given to the text
	 *
	 * @name CreateTextpieces
	 * @access private
	 * @since 3.5
	 * 
	 * @param $textObjects (array) - Text + Font of one paragraaf
	 * @param $noFontParagraaf (Boolean) - if this is False no font wil be given
	 * @return $ParagraafText (String) - a string which contains a paragraaf writting in dokuwiki Code.
	 */
	private function CreateTextpieces($textObjects, $noFontParagraaf) {

		//Output variable
		$ParagraafText = "";
		//previous textpiece object
		$previousTextPiece = new textPieces("", array('none'));
		//temp text variable
		$tempText = "";
		//loops over the text

		foreach ($textObjects as $textob) {
			switch ($textob->getClassName()) {
				case 'textpieces':
					if ($noFontParagraaf) {
						$ParagraafText .= $textob->getText();
					} else {
						$ParagraafText .= $this->addFont($textob);
					}
					break;
				case 'footnoteTextpieces':
					foreach ($this->buildingMaterials['subdocument']['footnotesXML'] as $footnoteInformationList) {
						if ($footnoteInformationList->getfootnoteId() == $textob->getId()) {
							$footnoteInformation = $footnoteInformationList;
							break;
						}
					}
					foreach ($footnoteInformation->gettextPieces() as $textpiece) {
						if ($this->markup['footnoteNoFont']) {
							$tempText .= $textpiece->getText();
						} else {
							$tempText .= $this->addFont($textpiece);

						}
					}
					$ParagraafText .= $this->markup['footnoteBegin'].$textob->getId().". ".$tempText.$this->markup['footnoteEnd'];
					$tempText = "";
					break;
				case 'hyperlinkTextpieces':
					if ($previousTextPiece->getClassName() == "hyperlinkTextpieces") {
						if ($textob->getId() == $previousTextPiece->getId()) {

							$ParagraafText = substr($ParagraafText, 0, -strlen($this->markup['HyperlinkEnd']));
							if ($this->markup['HyperlinkNoFont']){
								$ParagraafText.= $textob->getText().$this->markup['HyperlinkEnd'];
							} else {
							$ParagraafText .= $this->addFont($textob).$this->markup['HyperlinkEnd'];								
							}

						}
					} else {
						foreach ($this->buildingMaterials['subdocument']['referenceXML'] as $referenceInformationList) {
							if ($referenceInformationList->getId() == $textob->getId()) {
								$referenceTarget = $referenceInformationList->getTarget();
								break;
							}
						}

						$HyperBegin = str_replace("%hyperlinkTarget%", $referenceTarget, $this->markup['HyperlinkBegin']);
						if ($this->markup['HyperlinkNoFont']){
								$ParagraafText.= $HyperBegin.$textob->getText().$this->markup['HyperlinkEnd'];
						} else {
								$ParagraafText .= $HyperBegin.$this->addFont($textob).$this->markup['HyperlinkEnd'];
						}
						$previousTextPiece = $textob;

					}
					break;
			}
		}

		return $ParagraafText;

	}

	/**
	 * addFont - Methode which add the font
	 *
	 * This methode add font to a given piece of text
	 *
	 * @name addFont
	 * @access private
	 * @since 3.5
	 * 
	 * @param $textpiece (textpiece Object) - object which need styling
	 * @return $tempText (String) - a string with the fonted text.
	 */	
	 private function addFont($textpiece) {
		$fontarray = $textpiece->getFont();
		$tempText = $textpiece->getText();
		//loops over the font's within the text
		foreach ($fontarray as $font) {
			switch ($font) {
				//Make it bold
				case "Bold":
					$tempText = $this->markup['BoldBegin'].$tempText.$this->markup['BoldEnd'];
					break;
				//Make it Italic
				case "Italic":
					$tempText = $this->markup['ItalicBegin'].$tempText.$this->markup['ItalicEnd'];
					break;
				//Make it Underlined
				case "Underlined":
					$tempText = $this->markup['UnderlinedBegin'].$tempText.$this->markup['UnderlinedEnd'];
					break;
				//Gives it no style
				default:
					$tempText = $tempText;
					break;
			}
		}
		return $tempText;

	}

	/**
	 * getCreation - getter to get the generated code
	 *
	 * With this method you can get the code depending on the child class
	 * which is used
	 *
	 * @name getCreation
	 * @access public
	 * @since 2.0
	 *
	 */
	public function getCreation() {
		return $this->creationOuput;
	}

}
